/*
*****************************************Copyright (c)*********************************************
**									 广州立锐升电子有限公司
**                             Guangzhou Lrsun Electronic Co.,Ltd.
**
**                                    http://www.lrsun.net
**	文件名	：UserMath.c
**	程序员	:
**	日　期  ：2009年4月20日
**	文件描述：用户自定义的数学函数库。
**			  有时候根据特定的应用来定义自己的函数要比系统自带的执行效率要高。
***************************************************************************************************
*/

#include 	"UserMath.h"
#include <math.h>

/*
***************************************************************************************************
**                                         MathRound()
**	功能描述：小数点的四舍五入
**	参  数  ：indata		输入值
**			  precision		想要保留的小数位数
**
**	返回值  ：返回转换后的数值。
**
**  备  注  ：视应用而定，用双精度还是单精度。
**			  fp64 -> fp32
**            用双精度的话那个0.500001需修正为0.5000000001。因为双精度的小数点位数为10位，而单精
**            度的是6位。
***************************************************************************************************
*/
fp32 MathRound(fp32 indata, int8 precision)
{
	fp32  	dval;
	fp32	cf;
	fp32 	pn;
	fp32 	temp;
	int32 	i;


	if (precision<0)
		pn = 0.1;
	else
		pn = 10;

	cf = 1;
	for (i = 0; i<abs(precision); i++)
		cf *= pn;

	temp = indata*cf;

	if (temp >= 0.499999)			dval = (int32)(indata*cf + 0.500001) / cf;
	else if (temp <= -0.499999)	dval = (int32)(indata*cf - 0.500001) / cf;
	else 					    dval = (int32)(indata*cf) / cf;

	return dval;
}

/*
***************************************************************************************************
**
**                                         MathRound()
**
**
**	功能描述：小数点的四舍五入
**
**	参  数  ：indata		输入值地址
**			  precision		想要保留的小数位数
**
**	返回值  ：返回转换后的数值。
**
**  备  注  ：视应用而定，用双精度还是单精度。
**			  fp64 -> fp32
**            用双精度的话那个0.500001需修正为0.5000000001。因为双精度的小数点位数为10位，而单精
**            度的是6位。
**
***************************************************************************************************
*/
void MathRound1(fp32* indata, int8 precision)
{
	fp32  	dval;
	fp32	cf;
	fp32 	pn;
	fp32 	temp;
	uint32 	i;


	if (precision<0)
	{
		pn = 0.1;
	}
	else
	{
		pn = 10;
	}

	cf = 1;
	for (i = 0; i<abs(precision); i++)
	{
		cf *= pn;
	}

	temp = indata[0] * cf;

	if (temp >= 0.49)			dval = (int32)(indata[0] * cf + 0.500001) / cf;
	else if (temp <= -0.49)	dval = (int32)(indata[0] * cf - 0.500001) / cf;
	else 					dval = (int32)(indata[0] * cf) / cf;

	indata[0] = dval;
}

